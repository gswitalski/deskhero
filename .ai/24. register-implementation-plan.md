# API Endpoint Implementation Plan: POST /api/users/register

## 1. Przegląd punktu końcowego
Ten punkt końcowy umożliwia nowym użytkownikom rejestrację w systemie poprzez podanie unikalnej nazwy użytkownika (adresu e-mail), imienia i hasła. Po pomyślnej rejestracji zwraca potwierdzenie, podstawowe dane użytkownika oraz token JWT do uwierzytelniania kolejnych żądań.

## 2. Szczegóły żądania
- **Metoda HTTP**: `POST`
- **Struktura URL**: `/api/users/register`
- **Parametry**: Brak parametrów URL.
- **Request Body**:
  ```json
  {
    "username": "user@example.com", // Wymagany, String, musi być unikalnym adresem email
    "name": "John Doe",          // Wymagany, String
    "password": "securePassword"   // Wymagany, String, min. 8 znaków (do ustalenia)
  }
  ```

## 3. Wykorzystywane typy
- **DTO Żądania**: `pl.grsw.deskhero.dto.UserRegisterRequestDto`
  ```java
  public record UserRegisterRequestDto(
      @NotBlank @Email String username,
      @NotBlank String name,
      @NotBlank @Size(min = 8) String password // Przykładowa walidacja długości hasła
  ) {}
  ```
- **DTO Odpowiedzi**: `pl.grsw.deskhero.dto.UserRegisterResponseDto`
  ```java
  public record UserRegisterResponseDto(
      String message,
      UserDto user,
      String token
  ) {}
  ```
- **DTO Użytkownika (w odpowiedzi)**: `pl.grsw.deskhero.dto.UserDto`
  ```java
  public record UserDto(
      Long id,
      String username,
      String name
  ) {}
  ```
- **Model Domenowy**: `pl.grsw.deskhero.model.User`
- **DTO Błędu**: Standardowy DTO dla błędów obsługiwany przez `@ControllerAdvice` (np. `{ timestamp, status, error, message, path }`). Należy upewnić się, że taki globalny handler istnieje lub go stworzyć.

## 4. Szczegóły odpowiedzi
- **Sukces (201 Created)**:
  ```json
  {
    "message": "User registered successfully",
    "user": {
      "id": 1,
      "username": "user@example.com",
      "name": "John Doe"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." // Przykładowy token JWT
  }
  ```
- **Błędy**:
  - **400 Bad Request**: Zwracany, gdy walidacja `UserRegisterRequestDto` nie powiodła się (np. brakujące pola, niepoprawny format email, zbyt krótkie hasło). Odpowiedź powinna być w standardowym formacie błędu.
  - **409 Conflict**: Zwracany, gdy użytkownik o podanym `username` już istnieje. Odpowiedź powinna być w standardowym formacie błędu.
  - **500 Internal Server Error**: Zwracany w przypadku nieoczekiwanych błędów serwera (np. problem z bazą danych podczas zapisu, błąd generowania tokenu JWT). Odpowiedź powinna być w standardowym formacie błędu.

## 5. Przepływ danych
1.  Klient wysyła żądanie `POST` na `/api/users/register` z danymi użytkownika w ciele JSON.
2.  Spring MVC odbiera żądanie i mapuje je do metody w `UserController` (lub dedykowanym `AuthController`).
3.  Spring automatycznie waliduje przychodzące `UserRegisterRequestDto` za pomocą adnotacji Bean Validation. Jeśli walidacja zawiedzie, globalny `@ControllerAdvice` przechwytuje błąd i zwraca odpowiedź 400 Bad Request.
4.  Kontroler wywołuje metodę `registerUser` (lub podobną) w `UserService` (lub `AuthService`), przekazując `UserRegisterRequestDto`.
5.  Serwis sprawdza, czy użytkownik o podanym `username` już istnieje, odpytując `UserRepository`.
6.  Jeśli użytkownik istnieje, serwis rzuca dedykowany wyjątek (np. `UserAlreadyExistsException`). Globalny `@ControllerAdvice` przechwytuje ten wyjątek i zwraca odpowiedź 409 Conflict.
7.  Jeśli użytkownik nie istnieje, serwis hashuje hasło za pomocą wstrzykniętego `PasswordEncoder` (BCrypt).
8.  Serwis tworzy nową instancję encji `User` z podanymi danymi (zahashowane hasło).
9.  Serwis zapisuje encję `User` w bazie danych za pomocą `UserRepository`.
10. Serwis przypisuje domyślną rolę (np. "ROLE_USER") użytkownikowi (np. poprzez zapis w tabeli `authorities` lub inny mechanizm Spring Security).
11. Serwis wywołuje `JwtService` (lub podobny komponent) w celu wygenerowania tokenu JWT dla nowo utworzonego użytkownika.
12. Serwis mapuje nowo utworzoną encję `User` na `UserDto`.
13. Serwis zwraca obiekt zawierający `UserDto` i wygenerowany token JWT do kontrolera.
14. Kontroler konstruuje `UserRegisterResponseDto` z wiadomością o sukcesie, `UserDto` i tokenem.
15. Kontroler zwraca odpowiedź 201 Created z `UserRegisterResponseDto` w ciele.

## 6. Względy bezpieczeństwa
- **Hashowanie haseł**: Hasła muszą być hashowane przed zapisem do bazy danych przy użyciu silnego algorytmu (BCrypt jest standardem w Spring Security). Należy wstrzyknąć `PasswordEncoder`.
- **Walidacja danych wejściowych**: Stosować adnotacje Bean Validation (`@NotBlank`, `@Email`, `@Size`) w DTO żądania, aby zapobiegać nieprawidłowym danym i potencjalnym atakom (np. injection przez zbyt długie ciągi).
- **Unikalność nazwy użytkownika**: Zapewniona przez ograniczenie `UNIQUE` w bazie danych oraz sprawdzana w logice serwisowej przed próbą zapisu.
- **Generowanie JWT**: Używać biblioteki do generowania bezpiecznych tokenów JWT (np. `jjwt`), podpisywać je silnym kluczem tajnym (przechowywanym bezpiecznie w konfiguracji, nie w kodzie) i ustawiać czas wygaśnięcia (expiration time).
- **Ochrona przed CSRF**: Standardowa konfiguracja Spring Security powinna być przejrzana pod kątem ochrony CSRF, chociaż dla bezstanowych API opartych na tokenach ryzyko jest mniejsze, jeśli tokeny są przesyłane w nagłówkach `Authorization`.
- **HTTPS**: Cała komunikacja musi odbywać się przez HTTPS, aby chronić przesyłane dane (hasło, token JWT).
- **Rate Limiting**: Rozważyć implementację ograniczenia liczby żądań (np. za pomocą Spring Cloud Gateway lub dedykowanej biblioteki), aby chronić przed atakami typu brute-force na endpoint rejestracji.

## 7. Obsługa błędów
- **Błędy walidacji (400)**: Obsługiwane automatycznie przez Spring Boot i Bean Validation. Globalny `@ControllerAdvice` powinien przechwytywać `MethodArgumentNotValidException` i formatować odpowiedź jako standardowy `ErrorDto`, zawierający szczegóły błędów walidacji.
- **Konflikt nazwy użytkownika (409)**: `UserService` powinien rzucać dedykowany wyjątek (np. `UserAlreadyExistsException`). `@ControllerAdvice` powinien mieć handler dla tego wyjątku, który zwraca status 409 i odpowiedni komunikat w `ErrorDto`.
- **Błędy wewnętrzne (500)**: Wszelkie inne nieprzechwycone wyjątki (np. `DataAccessException` podczas zapisu do bazy, błędy generowania JWT) powinny być przechwytywane przez domyślny handler w `@ControllerAdvice`, który zwraca status 500 i generyczny komunikat błędu. Należy logować pełny stack trace błędu po stronie serwera.
- **Logowanie**: Używać SLF4J do logowania informacji o przebiegu operacji (np. pomyślna rejestracja) oraz szczegółów błędów.

## 8. Rozważania dotyczące wydajności
- **Zapytania do bazy danych**: Operacja wymaga co najmniej jednego zapytania sprawdzającego istnienie użytkownika i jednego zapytania zapisu. Są to zazwyczaj szybkie operacje na indeksowanej kolumnie `username`.
- **Hashowanie haseł**: BCrypt jest celowo zasobożerny, co jest cechą bezpieczeństwa. Nie powinno to stanowić problemu przy normalnym obciążeniu.
- **Generowanie JWT**: Jest to operacja relatywnie szybka.
- **Wąskie gardła**: Głównym potencjalnym wąskim gardłem może być baza danych przy bardzo dużym obciążeniu jednoczesnymi próbami rejestracji. Indeks na kolumnie `username` jest kluczowy.

## 9. Etapy wdrożenia
1.  **Utworzenie/Aktualizacja DTO**: Zweryfikować istnienie i poprawność `UserRegisterRequestDto`, `UserRegisterResponseDto`, `UserDto`. Dodać adnotacje walidacyjne do `UserRegisterRequestDto`. Upewnić się, że istnieje standardowy `ErrorDto`.
2.  **Aktualizacja Encji `User`**: Upewnić się, że encja `User` (`pl.grsw.deskhero.model.User`) ma odpowiednie pola (`id`, `username`, `name`, `password`) i mapowania JPA.
3.  **Aktualizacja `UserRepository`**: Upewnić się, że repozytorium (`pl.grsw.deskhero.repository.UserRepository`) dziedziczy po `JpaRepository` i zawiera metodę do wyszukiwania użytkownika po `username` (np. `Optional<User> findByUsername(String username);`).
4.  **Implementacja Logiki w Serwisie**:
    *   Utworzyć lub zaktualizować `UserService` (lub `AuthService`).
    *   Wstrzyknąć `UserRepository`, `PasswordEncoder` i `JwtService` (lub odpowiednik do generowania tokenów).
    *   Zaimplementować metodę `registerUser(UserRegisterRequestDto requestDto)`:
        *   Sprawdzenie istnienia użytkownika (`findByUsername`).
        *   Rzucenie `UserAlreadyExistsException` w przypadku konfliktu.
        *   Hashowanie hasła (`passwordEncoder.encode`).
        *   Tworzenie nowej encji `User`.
        *   Zapis użytkownika (`userRepository.save`).
        *   Przypisanie domyślnej roli (np. przez `JdbcUserDetailsManager` lub zapis do tabeli `authorities`).
        *   Wygenerowanie tokenu JWT (`jwtService.generateToken`).
        *   Zmapowanie encji `User` na `UserDto`.
        *   Zwrócenie obiektu DTO zawierającego `UserDto` i token.
5.  **Implementacja Kontrolera**:
    *   Utworzyć lub zaktualizować `UserController` (lub `AuthController`).
    *   Wstrzyknąć `UserService` (lub `AuthService`).
    *   Zaimplementować metodę obsługującą `POST /api/users/register`:
        *   Przyjąć `@Valid @RequestBody UserRegisterRequestDto`.
        *   Wywołać metodę serwisową `registerUser`.
        *   Skonstruować `UserRegisterResponseDto`.
        *   Zwrócić `ResponseEntity<UserRegisterResponseDto>` ze statusem `HttpStatus.CREATED`.
6.  **Konfiguracja Spring Security**:
    *   Upewnić się, że endpoint `/api/users/register` jest publicznie dostępny (nie wymaga uwierzytelnienia).
    *   Skonfigurować bean `PasswordEncoder` (np. `BCryptPasswordEncoder`).
    *   Skonfigurować obsługę ról/uprawnień (np. `JdbcUserDetailsManager`, jeśli używany).
7.  **Obsługa Błędów (`@ControllerAdvice`)**:
    *   Upewnić się, że istnieje globalny `@ControllerAdvice`.
    *   Dodać `@ExceptionHandler` dla `MethodArgumentNotValidException` zwracający 400 Bad Request i `ErrorDto`.
    *   Dodać `@ExceptionHandler` dla `UserAlreadyExistsException` zwracający 409 Conflict i `ErrorDto`.
    *   Dodać generyczny `@ExceptionHandler` dla `Exception` zwracający 500 Internal Server Error i `ErrorDto`.
8.  **Utworzenie/Konfiguracja `JwtService`**: Zaimplementować lub skonfigurować serwis odpowiedzialny za generowanie i walidację tokenów JWT. Upewnić się, że klucz tajny jest bezpiecznie zarządzany.
9.  **Testy**:
    *   **Testy jednostkowe**: dla `UserService` (mockując zależności: `UserRepository`, `PasswordEncoder`, `JwtService`) i `UserController` (mockując `UserService`).
    *   **Testy integracyjne**: dla endpointu `/api/users/register` używając `@SpringBootTest` i `MockMvc`, testując scenariusze sukcesu, błędów walidacji (400) i konfliktu (409).
10. **Dokumentacja**: Zaktualizować dokumentację API (np. Swagger/OpenAPI), jeśli jest używana. 
